# Development notes
This file contains various notes about the project that may be useful during development.
It's not full documentation, but it should shed some light on the project's inner workings.

**EDIT from the future:** This note is nice but a good way to understand
the code is to just read it starting from `GuiProjectApp.generate()`.
It is not as complicated as it seems but you will need about 1.5-2 hours
to read and understand it if you're getting back to it after a long break.
Then it's relatively easy to find the place where you want to make changes.


## Generators and Closures

The project uses a lot of generators. This pattern was chosen because it allows to
schedule the execution of the code for later. Python is not the best language for
for multi-threading, but the GUI of the application requires that. The generators
divide the work into small chunks. This section explains how they work.

Everything starts with the press of the "Generate" button which calls the
`GuiProjectApp.start_generating()` method.

The `start_generating()` method starts a new thread which calls the
`threaded_generate()` method. Simultaneusly the `watch_thread_generate()`
method is scheduled to be called in the main thread to controll the progress
of the process and update the progress bar.

The `threaded_generate()` method loops through the
`Project.yield_book_creation_aciton()` and sends updates to the main thread
about the progress.

The `Project` object is the main object that produces the jobs. The
`Project.yield_book_creation_aciton()` generates images for the book by
yielding from `Project.yield_page_creation_actions()` method.

The `Project.yield_page_creation_actions()` takes a template and a list of paths
to recipe files and generates functions that will render the images.

A "page_ceration_action" creates a single page, every page is created from a
**background and a list of page items** (like recipe, images, textfields).
Page items are created by functions which are build by
`Project.get_page_item_creation_action()` method. **In case of recipe page
items** this method searches for the first matching recipe available on the list and
returns a function generate it.

The recipe page items are images of the recipes. The are composed from images
of the Minecraft items placed on a background. The images of the items are
generated by `get_image_provider()` function. The `get_image_provider()` function
is not guaranteed to return an image. Somtimes the data is not sufficient to
find the texture. In this case the interactive_texture_getter can by called
to get the texture from the user.

The image provider closeres are called inside the actions o
`get_page_item_creation_action()`, which are called inside the
the actions of `get_page_creation_action()`, which are the "job steps".

**Summary:**
- `Project.yield_book_creation_aciton()` creates job steps using...
- `Project.yield_page_creation_actions()` creates job steps using...
- `Project.get_page_creation_action()` which, in the returned closure, calls...
- `Project.get_page_item_creation_action()` that composes images using closures from...
- `get_image_provider()` that sometimes may call `interactive_texture_getter()`

# Threading
The threading is completely handled inside the `GuiProjectApp` class in `gui.py`
module.

In general there are two threads:
- the main thread - handles the Tkinter GUI
- the worker thread - handles various tasks

The worker thread is accessed through the `GuiProjectApp.worker_thread`
attribute. Stopping the main thread should also stop the worker thread but
it's not that easy. The application runs in a context manager. The `__exit__`
function tries to notify the worker thread that it should stop. The
`GuiProjectApp.stop` `Event` is used for this purpose. The worker thread
checks for the stop event every now and then.

Additionally the `__exit__` function sends a dummy value to a
`self.interactive_mode_queue` (explained later) to make sure that the worker
thread is not waiting for input from the user and won't get locked.

## Tasks of the worker thread

There are 2 types of tasks that the worker thread can do:
- Generating the book images
- Syncing the database

### Generating the books
This is the main purpose of the application. The worker thread runs tasks from
`Project.yield_book_creation_aciton()` mentioned above.

While doing this it uses `GuiProjectApp.progress_bar_update_queue` to send
the updates in form of `ProgressBarUpdate` objects to the main thread. The
updates contain the data for the progress bar.

The book generation loop also checks if `GuiProjectApp.stop` event is set. If
it is, the loop breaks and the worker thread stops.

Whiele the `GuiProjectApp` is created it runs
`setup_project_interactive_texture_getter` it gives the `Project` object
access to a new function (closure) `worker_request_path` which is used for
requesting the path to the texture by the `worker_thread`.

Here is the process of requesting the path to the texture:
1. The worker thread can't find the texture and calls `worker_request_path`
2. This puts a new item on the `GuiProjectApp.request_path_queue` with the
   information about the item that needs the texture.
3. Right after putting the item the worker thread starts waiting for updates
   on the `GuiProjectApp.interactive_mode_queue`.
3. During the entire process the main thread is running its
  `watch_thread_generate` repeatedly. When it observes taht the `request_path_queue`
  is not empty it displays a dialog to the user asking for the path to the
  texture.
4. When the user selects the texture or closes the dialog a new item is put on
   the `GuiProjectApp.interactive_mode_queue`. The worker thread is waiting for
   this item and when it gets it it continues the generation process.

### Syncing the database
Syncing the database is way simpler. It's all done in one step so it's
impossible to stop the process when it's running.

The main thread starts it by calling `GuiProjectApp.start_syncing_database()`.
This runs the `force_pull_database` funuction on the new thread and disables
the UI. The main thread watches the process using
`GuiProjectApp.watch_thread_sync_database`. When the process is done the UI is
enabled again.
